{"ast":null,"code":"import { __read, __spreadArray } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport process from '../../utils/process.mjs';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\n\nvar getChildKey = function (child) {\n  return child.key || \"\";\n};\n\nvar isDev = process.env.NODE_ENV !== \"production\";\n\nfunction updateChildLookup(children, allChildren) {\n  var seenChildren = isDev ? new Set() : null;\n  children.forEach(function (child) {\n    var key = getChildKey(child);\n\n    if (isDev && seenChildren && seenChildren.has(key)) {\n      console.warn(\"Children of AnimatePresence require unique keys. \\\"\".concat(key, \"\\\" is a duplicate.\"));\n      seenChildren.add(key);\n    }\n\n    allChildren.set(key, child);\n  });\n}\n\nfunction onlyElements(children) {\n  var filtered = []; // We use forEach here instead of map as map mutates the component key by preprending `.$`\n\n  Children.forEach(children, function (child) {\n    if (isValidElement(child)) filtered.push(child);\n  });\n  return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\n\n\nvar AnimatePresence = function (_a) {\n  var children = _a.children,\n      custom = _a.custom,\n      _b = _a.initial,\n      initial = _b === void 0 ? true : _b,\n      onExitComplete = _a.onExitComplete,\n      exitBeforeEnter = _a.exitBeforeEnter,\n      _c = _a.presenceAffectsLayout,\n      presenceAffectsLayout = _c === void 0 ? true : _c; // We want to force a re-render once all exiting animations have finished. We\n  // either use a local forceRender function, or one from a parent context if it exists.\n\n  var _d = __read(useForceUpdate(), 1),\n      forceRender = _d[0];\n\n  var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n  if (forceRenderLayoutGroup) forceRender = forceRenderLayoutGroup;\n  var isMounted = useIsMounted(); // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n\n  var filteredChildren = onlyElements(children);\n  var childrenToRender = filteredChildren;\n  var exiting = new Set(); // Keep a living record of the children we're actually rendering so we\n  // can diff to figure out which are entering and exiting\n\n  var presentChildren = useRef(childrenToRender); // A lookup table to quickly reference components by key\n\n  var allChildren = useRef(new Map()).current; // If this is the initial component render, just deal with logic surrounding whether\n  // we play onMount animations or not.\n\n  var isInitialRender = useRef(true);\n  useIsomorphicLayoutEffect(function () {\n    isInitialRender.current = false;\n    updateChildLookup(filteredChildren, allChildren);\n    presentChildren.current = childrenToRender;\n  });\n  useUnmountEffect(function () {\n    isInitialRender.current = true;\n    allChildren.clear();\n    exiting.clear();\n  });\n\n  if (isInitialRender.current) {\n    return React.createElement(React.Fragment, null, childrenToRender.map(function (child) {\n      return React.createElement(PresenceChild, {\n        key: getChildKey(child),\n        isPresent: true,\n        initial: initial ? undefined : false,\n        presenceAffectsLayout: presenceAffectsLayout\n      }, child);\n    }));\n  } // If this is a subsequent render, deal with entering and exiting children\n\n\n  childrenToRender = __spreadArray([], __read(childrenToRender), false); // Diff the keys of the currently-present and target children to update our\n  // exiting list.\n\n  var presentKeys = presentChildren.current.map(getChildKey);\n  var targetKeys = filteredChildren.map(getChildKey); // Diff the present children with our target children and mark those that are exiting\n\n  var numPresent = presentKeys.length;\n\n  for (var i = 0; i < numPresent; i++) {\n    var key = presentKeys[i];\n\n    if (targetKeys.indexOf(key) === -1) {\n      exiting.add(key);\n    }\n  } // If we currently have exiting children, and we're deferring rendering incoming children\n  // until after all current children have exiting, empty the childrenToRender array\n\n\n  if (exitBeforeEnter && exiting.size) {\n    childrenToRender = [];\n  } // Loop through all currently exiting components and clone them to overwrite `animate`\n  // with any `exit` prop they might have defined.\n\n\n  exiting.forEach(function (key) {\n    // If this component is actually entering again, early return\n    if (targetKeys.indexOf(key) !== -1) return;\n    var child = allChildren.get(key);\n    if (!child) return;\n    var insertionIndex = presentKeys.indexOf(key);\n\n    var onExit = function () {\n      allChildren.delete(key);\n      exiting.delete(key); // Remove this child from the present children\n\n      var removeIndex = presentChildren.current.findIndex(function (presentChild) {\n        return presentChild.key === key;\n      });\n      presentChildren.current.splice(removeIndex, 1); // Defer re-rendering until all exiting children have indeed left\n\n      if (!exiting.size) {\n        presentChildren.current = filteredChildren;\n        if (isMounted.current === false) return;\n        forceRender();\n        onExitComplete && onExitComplete();\n      }\n    };\n\n    childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: false,\n      onExitComplete: onExit,\n      custom: custom,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child));\n  }); // Add `MotionContext` even to children that don't need it to ensure we're rendering\n  // the same tree between renders\n\n  childrenToRender = childrenToRender.map(function (child) {\n    var key = child.key;\n    return exiting.has(key) ? child : React.createElement(PresenceChild, {\n      key: getChildKey(child),\n      isPresent: true,\n      presenceAffectsLayout: presenceAffectsLayout\n    }, child);\n  });\n\n  if (process.env.NODE_ENV !== \"production\" && exitBeforeEnter && childrenToRender.length > 1) {\n    console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n  }\n\n  return React.createElement(React.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function (child) {\n    return cloneElement(child);\n  }));\n};\n\nexport { AnimatePresence };","map":{"version":3,"names":["__read","__spreadArray","React","useContext","useRef","cloneElement","Children","isValidElement","process","useForceUpdate","useIsMounted","PresenceChild","LayoutGroupContext","useIsomorphicLayoutEffect","useUnmountEffect","getChildKey","child","key","isDev","env","NODE_ENV","updateChildLookup","children","allChildren","seenChildren","Set","forEach","has","console","warn","concat","add","set","onlyElements","filtered","push","AnimatePresence","_a","custom","_b","initial","onExitComplete","exitBeforeEnter","_c","presenceAffectsLayout","_d","forceRender","forceRenderLayoutGroup","isMounted","filteredChildren","childrenToRender","exiting","presentChildren","Map","current","isInitialRender","clear","createElement","Fragment","map","isPresent","undefined","presentKeys","targetKeys","numPresent","length","i","indexOf","size","get","insertionIndex","onExit","delete","removeIndex","findIndex","presentChild","splice"],"sources":["/Users/ingeborg/projects/code/typescript-ws-2022/node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs"],"sourcesContent":["import { __read, __spreadArray } from 'tslib';\nimport * as React from 'react';\nimport { useContext, useRef, cloneElement, Children, isValidElement } from 'react';\nimport process from '../../utils/process.mjs';\nimport { useForceUpdate } from '../../utils/use-force-update.mjs';\nimport { useIsMounted } from '../../utils/use-is-mounted.mjs';\nimport { PresenceChild } from './PresenceChild.mjs';\nimport { LayoutGroupContext } from '../../context/LayoutGroupContext.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\nimport { useUnmountEffect } from '../../utils/use-unmount-effect.mjs';\n\nvar getChildKey = function (child) { return child.key || \"\"; };\nvar isDev = process.env.NODE_ENV !== \"production\";\nfunction updateChildLookup(children, allChildren) {\n    var seenChildren = isDev ? new Set() : null;\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        if (isDev && seenChildren && seenChildren.has(key)) {\n            console.warn(\"Children of AnimatePresence require unique keys. \\\"\".concat(key, \"\\\" is a duplicate.\"));\n            seenChildren.add(key);\n        }\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    Children.forEach(children, function (child) {\n        if (isValidElement(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from 'framer-motion'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var _d = __read(useForceUpdate(), 1), forceRender = _d[0];\n    var forceRenderLayoutGroup = useContext(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup)\n        forceRender = forceRenderLayoutGroup;\n    var isMounted = useIsMounted();\n    // Filter out any children that aren't ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    var childrenToRender = filteredChildren;\n    var exiting = new Set();\n    // Keep a living record of the children we're actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = useRef(childrenToRender);\n    // A lookup table to quickly reference components by key\n    var allChildren = useRef(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    var isInitialRender = useRef(true);\n    useIsomorphicLayoutEffect(function () {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(function () {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exiting.clear();\n    });\n    if (isInitialRender.current) {\n        return (React.createElement(React.Fragment, null, childrenToRender.map(function (child) { return (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = __spreadArray([], __read(childrenToRender), false);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n    }\n    // If we currently have exiting children, and we're deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false)\n                    return;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, React.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don't need it to ensure we're rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (React.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    if (process.env.NODE_ENV !== \"production\" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn(\"You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.\");\n    }\n    return (React.createElement(React.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return cloneElement(child); })));\n};\n\nexport { AnimatePresence };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}