import { chakra, useChakra, ThemeProvider, ColorModeContext } from '@chakra-ui/system';
import * as React from 'react';
import { runIfFn, __DEV__, objectKeys, isFunction, noop } from '@chakra-ui/utils';
import { useUpdateEffect, useTimeout, useLatestRef } from '@chakra-ui/hooks';
import { useIsPresent, motion, AnimatePresence } from 'framer-motion';
import { createContext } from '@chakra-ui/react-utils';
import { Portal } from '@chakra-ui/portal';
import { Alert, AlertIcon, AlertTitle, AlertDescription } from '@chakra-ui/alert';
import { CloseButton } from '@chakra-ui/close-button';
import defaultTheme from '@chakra-ui/theme';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function getToastPlacement(position, dir) {
  var _logical$dir;

  if (!position) return;
  var logicals = {
    "top-start": {
      ltr: "top-left",
      rtl: "top-right"
    },
    "top-end": {
      ltr: "top-right",
      rtl: "top-left"
    },
    "bottom-start": {
      ltr: "bottom-left",
      rtl: "bottom-right"
    },
    "bottom-end": {
      ltr: "bottom-right",
      rtl: "bottom-left"
    }
  };
  var logical = logicals[position];
  return (_logical$dir = logical == null ? void 0 : logical[dir]) != null ? _logical$dir : position;
}

/**
 * Given an array of toasts for a specific position.
 * It returns the toast that matches the `id` passed
 */
/**
 * Given the toast manager state, finds the toast that matches
 * the id and return its position and index
 */

function findToast(toasts, id) {
  var position = getToastPosition(toasts, id);
  var index = position ? toasts[position].findIndex(function (toast) {
    return toast.id === id;
  }) : -1;
  return {
    position: position,
    index: index
  };
}
/**
 * Given the toast manager state, finds the position of the toast that
 * matches the `id`
 */

var getToastPosition = function getToastPosition(toasts, id) {
  var _Object$values$flat$f;

  return (_Object$values$flat$f = Object.values(toasts).flat().find(function (toast) {
    return toast.id === id;
  })) == null ? void 0 : _Object$values$flat$f.position;
};
/**
 * Gets the styles to be applied to a toast's container
 * based on its position in the manager
 */

function getToastStyle(position) {
  var isRighty = position.includes("right");
  var isLefty = position.includes("left");
  var alignItems = "center";
  if (isRighty) alignItems = "flex-end";
  if (isLefty) alignItems = "flex-start";
  return {
    display: "flex",
    flexDirection: "column",
    alignItems: alignItems
  };
}

var toastMotionVariants = {
  initial: function initial(props) {
    var _ref;

    var position = props.position;
    var dir = ["top", "bottom"].includes(position) ? "y" : "x";
    var factor = ["top-right", "bottom-right"].includes(position) ? 1 : -1;
    if (position === "bottom") factor = 1;
    return _ref = {
      opacity: 0
    }, _ref[dir] = factor * 24, _ref;
  },
  animate: {
    opacity: 1,
    y: 0,
    x: 0,
    scale: 1,
    transition: {
      duration: 0.4,
      ease: [0.4, 0, 0.2, 1]
    }
  },
  exit: {
    opacity: 0,
    scale: 0.85,
    transition: {
      duration: 0.2,
      ease: [0.4, 0, 1, 1]
    }
  }
};
var ToastComponent = /*#__PURE__*/React.memo(function (props) {
  var id = props.id,
      message = props.message,
      onCloseComplete = props.onCloseComplete,
      onRequestRemove = props.onRequestRemove,
      _props$requestClose = props.requestClose,
      requestClose = _props$requestClose === void 0 ? false : _props$requestClose,
      _props$position = props.position,
      position = _props$position === void 0 ? "bottom" : _props$position,
      _props$duration = props.duration,
      duration = _props$duration === void 0 ? 5000 : _props$duration,
      containerStyle = props.containerStyle,
      _props$motionVariants = props.motionVariants,
      motionVariants = _props$motionVariants === void 0 ? toastMotionVariants : _props$motionVariants,
      _props$toastSpacing = props.toastSpacing,
      toastSpacing = _props$toastSpacing === void 0 ? "0.5rem" : _props$toastSpacing;

  var _React$useState = React.useState(duration),
      delay = _React$useState[0],
      setDelay = _React$useState[1];

  var isPresent = useIsPresent();
  useUpdateEffect(function () {
    if (!isPresent) {
      onCloseComplete == null ? void 0 : onCloseComplete();
    }
  }, [isPresent]);
  useUpdateEffect(function () {
    setDelay(duration);
  }, [duration]);

  var onMouseEnter = function onMouseEnter() {
    return setDelay(null);
  };

  var onMouseLeave = function onMouseLeave() {
    return setDelay(duration);
  };

  var close = function close() {
    if (isPresent) onRequestRemove();
  };

  React.useEffect(function () {
    if (isPresent && requestClose) {
      onRequestRemove();
    }
  }, [isPresent, requestClose, onRequestRemove]);
  useTimeout(close, delay);
  var containerStyles = React.useMemo(function () {
    return _extends({
      pointerEvents: "auto",
      maxWidth: 560,
      minWidth: 300,
      margin: toastSpacing
    }, containerStyle);
  }, [containerStyle, toastSpacing]);
  var toastStyle = React.useMemo(function () {
    return getToastStyle(position);
  }, [position]);
  return /*#__PURE__*/React.createElement(motion.li, {
    layout: true,
    className: "chakra-toast",
    variants: motionVariants,
    initial: "initial",
    animate: "animate",
    exit: "exit",
    onHoverStart: onMouseEnter,
    onHoverEnd: onMouseLeave,
    custom: {
      position: position
    },
    style: toastStyle
  }, /*#__PURE__*/React.createElement(chakra.div, {
    role: "status",
    "aria-atomic": "true",
    className: "chakra-toast__inner",
    __css: containerStyles
  }, runIfFn(message, {
    id: id,
    onClose: close
  })));
});

if (__DEV__) {
  ToastComponent.displayName = "ToastComponent";
}

/**
 * Static id counter to create unique ids
 * for each toast
 */
var counter = 0;
function useToastProvider(defaultOptions) {
  if (defaultOptions === void 0) {
    defaultOptions = {};
  }

  /**
   * State to track all the toast across all positions
   */
  var _React$useState = React.useState({
    top: [],
    "top-left": [],
    "top-right": [],
    "bottom-left": [],
    bottom: [],
    "bottom-right": []
  }),
      areas = _React$useState[0],
      setAreas = _React$useState[1];
  /**
   * Compute the style of a toast based on its position
   */


  var getStyle = function getStyle(position) {
    var isTopOrBottom = position === "top" || position === "bottom";
    var margin = isTopOrBottom ? "0 auto" : undefined;
    var top = position.includes("top") ? "env(safe-area-inset-top, 0px)" : undefined;
    var bottom = position.includes("bottom") ? "env(safe-area-inset-bottom, 0px)" : undefined;
    var right = !position.includes("left") ? "env(safe-area-inset-right, 0px)" : undefined;
    var left = !position.includes("right") ? "env(safe-area-inset-left, 0px)" : undefined;
    return {
      position: "fixed",
      zIndex: 5500,
      pointerEvents: "none",
      display: "flex",
      flexDirection: "column",
      margin: margin,
      top: top,
      bottom: bottom,
      right: right,
      left: left
    };
  };

  var toast = React.useMemo(function () {
    /**
     * Function to actually create a toast and add it
     * to state at the specified position
     */
    var notify = function notify(message, options) {
      var toast = createToast(message, _extends({}, defaultOptions, options));
      var position = toast.position,
          id = toast.id;
      setAreas(function (prevToasts) {
        var _prevToasts$position, _prevToasts$position2, _extends2;

        var isTop = position.includes("top");
        /**
         * - If the toast is positioned at the top edges, the
         * recent toast stacks on top of the other toasts.
         *
         * - If the toast is positioned at the bottom edges, the recent
         * toast stacks below the other toasts.
         */

        var toasts = isTop ? [toast].concat((_prevToasts$position = prevToasts[position]) != null ? _prevToasts$position : []) : [].concat((_prevToasts$position2 = prevToasts[position]) != null ? _prevToasts$position2 : [], [toast]);
        return _extends({}, prevToasts, (_extends2 = {}, _extends2[position] = toasts, _extends2));
      });
      return id;
    };
    /**
     * Update a specific toast with new options based on the
     * passed `id`
     */


    var update = function update(id, options) {
      setAreas(function (prevState) {
        var nextState = _extends({}, prevState);

        var _findToast = findToast(nextState, id),
            position = _findToast.position,
            index = _findToast.index;

        if (position && index !== -1) {
          nextState[position][index] = _extends({}, nextState[position][index], options);
        }

        return nextState;
      });
    };
    /**
     * Close all toasts at once.
     * If given positions, will only close those.
     */


    var closeAll = function closeAll(_temp) {
      var _ref = _temp === void 0 ? {} : _temp,
          positions = _ref.positions;

      // only one setState here for perf reasons
      // instead of spamming this.closeToast
      setAreas(function (prev) {
        var allPositions = ["bottom", "bottom-right", "bottom-left", "top", "top-left", "top-right"];
        var positionsToClose = positions != null ? positions : allPositions;
        return positionsToClose.reduce(function (acc, position) {
          acc[position] = prev[position].map(function (toast) {
            return _extends({}, toast, {
              requestClose: true
            });
          });
          return acc;
        }, _extends({}, prev));
      });
    };
    /**
     * Create properties for a new toast
     */


    var createToast = function createToast(message, options) {
      var _options$id, _options$position;

      counter += 1;
      var id = (_options$id = options.id) != null ? _options$id : counter;
      var position = (_options$position = options.position) != null ? _options$position : "top";
      /**
       * Delete a toast record at its position
       */

      var removeToast = function removeToast(id, position) {
        setAreas(function (prevState) {
          var _extends3;

          return _extends({}, prevState, (_extends3 = {}, _extends3[position] = prevState[position].filter(function (toast) {
            return toast.id != id;
          }), _extends3));
        });
      };

      return {
        id: id,
        message: message,
        position: position,
        duration: options.duration,
        onCloseComplete: options.onCloseComplete,
        onRequestRemove: function onRequestRemove() {
          return removeToast(String(id), position);
        },
        status: options.status,
        requestClose: false,
        containerStyle: options.containerStyle
      };
    };
    /**
     * Requests to close a toast based on its id and position
     */


    var close = function close(id) {
      setAreas(function (prevState) {
        var _extends4;

        var position = getToastPosition(prevState, id);
        if (!position) return prevState;
        return _extends({}, prevState, (_extends4 = {}, _extends4[position] = prevState[position].map(function (toast) {
          // id may be string or number
          // eslint-disable-next-line eqeqeq
          if (toast.id == id) {
            return _extends({}, toast, {
              requestClose: true
            });
          }

          return toast;
        }), _extends4));
      });
    };

    var isActive = function isActive(id) {
      var _findToast2 = findToast(areas, id),
          position = _findToast2.position;

      return Boolean(position);
    };

    return {
      notify: notify,
      closeAll: closeAll,
      close: close,
      update: update,
      isActive: isActive
    };
  }, [defaultOptions, areas]);
  return {
    areas: areas,
    getStyle: getStyle,
    toast: toast
  };
}

var _createContext = createContext({
  strict: true,
  name: "ToastManagerContext"
}),
    ToastManagerProvider = _createContext[0],
    useToastManager = _createContext[1];

/**
 * Manages the creation, and removal of toasts
 * across all corners ("top", "bottom", etc.)
 */
var ToastProvider = /*#__PURE__*/React.forwardRef(function (props, ref) {
  var children = props.children,
      defaultOptions = props.defaultOptions,
      motionVariants = props.motionVariants,
      _props$component = props.component,
      CustomToastComponent = _props$component === void 0 ? ToastComponent : _props$component;

  var _useToastProvider = useToastProvider({
    defaultOptions: defaultOptions
  }),
      areas = _useToastProvider.areas,
      getStyle = _useToastProvider.getStyle,
      toast = _useToastProvider.toast; // attach `toast` methods to the ref of this component for `createStandaloneToast`


  React.useImperativeHandle(ref, function () {
    return toast;
  });
  var toastList = objectKeys(areas).map(function (position) {
    var toasts = areas[position];
    return /*#__PURE__*/React.createElement("ul", {
      role: "region",
      "aria-live": "polite",
      key: position,
      id: "chakra-toast-manager-" + position,
      style: getStyle(position)
    }, /*#__PURE__*/React.createElement(AnimatePresence, {
      initial: false
    }, toasts.map(function (toast) {
      return /*#__PURE__*/React.createElement(CustomToastComponent, _extends({
        key: toast.id,
        motionVariants: motionVariants
      }, toast));
    })));
  });
  return /*#__PURE__*/React.createElement(ToastManagerProvider, {
    value: toast
  }, children, /*#__PURE__*/React.createElement(Portal, null, toastList));
});

var Toast = function Toast(props) {
  var status = props.status,
      _props$variant = props.variant,
      variant = _props$variant === void 0 ? "solid" : _props$variant,
      id = props.id,
      title = props.title,
      isClosable = props.isClosable,
      onClose = props.onClose,
      description = props.description,
      icon = props.icon;
  var alertTitleId = typeof id !== "undefined" ? "toast-" + id + "-title" : undefined;
  return /*#__PURE__*/React.createElement(Alert, {
    status: status,
    variant: variant,
    id: String(id),
    alignItems: "start",
    borderRadius: "md",
    boxShadow: "lg",
    paddingEnd: 8,
    textAlign: "start",
    width: "auto",
    "aria-labelledby": alertTitleId
  }, /*#__PURE__*/React.createElement(AlertIcon, null, icon), /*#__PURE__*/React.createElement(chakra.div, {
    flex: "1",
    maxWidth: "100%"
  }, title && /*#__PURE__*/React.createElement(AlertTitle, {
    id: alertTitleId
  }, title), description && /*#__PURE__*/React.createElement(AlertDescription, {
    display: "block"
  }, description)), isClosable && /*#__PURE__*/React.createElement(CloseButton, {
    size: "sm",
    onClick: onClose,
    position: "absolute",
    insetEnd: 1,
    top: 1
  }));
};
function createRenderToast(options) {
  if (options === void 0) {
    options = {};
  }

  var _options = options,
      render = _options.render,
      _options$toastCompone = _options.toastComponent,
      ToastComponent = _options$toastCompone === void 0 ? Toast : _options$toastCompone;

  var renderToast = function renderToast(props) {
    if (isFunction(render)) {
      return render(props);
    }

    return /*#__PURE__*/React.createElement(ToastComponent, _extends({}, props, options));
  };

  return renderToast;
}

/**
 * React hook used to create a function that can be used
 * to show toasts in an application.
 */
function useToast(defaultOptions) {
  var _useChakra = useChakra(),
      theme = _useChakra.theme;

  var toastContext = useToastManager();
  var latestToastContextRef = useLatestRef(toastContext);
  return React.useMemo(function () {
    var normalizeToastOptions = function normalizeToastOptions(options) {
      return _extends({}, defaultOptions, options, {
        position: getToastPlacement(options == null ? void 0 : options.position, theme.direction)
      });
    };

    var toast = function toast(options) {
      var normalizedToastOptions = normalizeToastOptions(options);
      var Message = createRenderToast(normalizedToastOptions);
      return latestToastContextRef.current.notify(Message, normalizedToastOptions);
    };

    toast.close = latestToastContextRef.current.close;
    toast.closeAll = latestToastContextRef.current.closeAll;
    /**
     * Toasts can only be updated if they have a valid id
     */

    toast.update = function (id, options) {
      if (!id) return;
      var normalizedToastOptions = normalizeToastOptions(options);
      var Message = createRenderToast(normalizedToastOptions);
      latestToastContextRef.current.update(id, _extends({}, normalizedToastOptions, {
        message: Message
      }));
    };

    toast.promise = function (promise, options) {
      var id = toast(_extends({}, options.loading, {
        status: "loading",
        duration: null
      }));
      promise.then(function (data) {
        return toast.update(id, _extends({
          status: "success",
          duration: 5000
        }, runIfFn(options.success, data)));
      })["catch"](function (error) {
        return toast.update(id, _extends({
          status: "error",
          duration: 5000
        }, runIfFn(options.error, error)));
      });
    };

    toast.isActive = latestToastContextRef.current.isActive;
    return toast;
  }, [defaultOptions, latestToastContextRef, theme.direction]);
}

var defaults = {
  duration: 5000,
  position: "bottom",
  variant: "solid"
};
var defaultStandaloneParam = {
  theme: defaultTheme,
  colorMode: "light",
  toggleColorMode: noop,
  setColorMode: noop,
  defaultOptions: defaults
};
/**
 * Create a toast
 */

function createStandaloneToast(_temp) {
  var _ref$current$notify, _ref$current3, _ref$current$closeAll, _ref$current4, _ref$current$close, _ref$current5, _ref$current$isActive, _ref$current6;

  var _ref = _temp === void 0 ? defaultStandaloneParam : _temp,
      _ref$theme = _ref.theme,
      theme = _ref$theme === void 0 ? defaultStandaloneParam.theme : _ref$theme,
      _ref$colorMode = _ref.colorMode,
      colorMode = _ref$colorMode === void 0 ? defaultStandaloneParam.colorMode : _ref$colorMode,
      _ref$toggleColorMode = _ref.toggleColorMode,
      toggleColorMode = _ref$toggleColorMode === void 0 ? defaultStandaloneParam.toggleColorMode : _ref$toggleColorMode,
      _ref$setColorMode = _ref.setColorMode,
      setColorMode = _ref$setColorMode === void 0 ? defaultStandaloneParam.setColorMode : _ref$setColorMode,
      _ref$defaultOptions = _ref.defaultOptions,
      defaultOptions = _ref$defaultOptions === void 0 ? defaultStandaloneParam.defaultOptions : _ref$defaultOptions,
      motionVariants = _ref.motionVariants,
      toastSpacing = _ref.toastSpacing,
      component = _ref.component;

  var ref = /*#__PURE__*/React.createRef();
  var colorModeContextValue = {
    colorMode: colorMode,
    setColorMode: setColorMode,
    toggleColorMode: toggleColorMode
  };

  var ToastContainer = function ToastContainer() {
    return /*#__PURE__*/React.createElement(ThemeProvider, {
      theme: theme
    }, /*#__PURE__*/React.createElement(ColorModeContext.Provider, {
      value: colorModeContextValue
    }, /*#__PURE__*/React.createElement(ToastProvider, {
      ref: ref,
      defaultOptions: defaultOptions,
      motionVariants: motionVariants,
      toastSpacing: toastSpacing,
      component: component
    })));
  };

  var normalizeToastOptions = function normalizeToastOptions(options) {
    return _extends({}, defaultOptions, options, {
      position: getToastPlacement(options == null ? void 0 : options.position, theme.direction)
    });
  };

  var toast = function toast(options) {
    var _ref$current;

    var normalizedToastOptions = normalizeToastOptions(options);
    var Message = createRenderToast(normalizedToastOptions);
    return (_ref$current = ref.current) == null ? void 0 : _ref$current.notify(Message, normalizedToastOptions);
  };
  /**
   * Toasts can only be updated if they have a valid id
   */


  toast.update = function (id, options) {
    var _ref$current2;

    if (!id) return;
    var normalizedToastOptions = normalizeToastOptions(options);
    var Message = createRenderToast(normalizedToastOptions);
    (_ref$current2 = ref.current) == null ? void 0 : _ref$current2.update(id, _extends({}, normalizedToastOptions, {
      message: Message
    }));
  };

  toast.notify = (_ref$current$notify = (_ref$current3 = ref.current) == null ? void 0 : _ref$current3.notify) != null ? _ref$current$notify : noop;
  toast.closeAll = (_ref$current$closeAll = (_ref$current4 = ref.current) == null ? void 0 : _ref$current4.closeAll) != null ? _ref$current$closeAll : noop;
  toast.close = (_ref$current$close = (_ref$current5 = ref.current) == null ? void 0 : _ref$current5.close) != null ? _ref$current$close : noop;
  toast.isActive = (_ref$current$isActive = (_ref$current6 = ref.current) == null ? void 0 : _ref$current6.isActive) != null ? _ref$current$isActive : noop;
  return {
    ToastContainer: ToastContainer,
    toast: toast
  };
}

export { Toast, ToastProvider, createRenderToast, createStandaloneToast, defaultStandaloneParam, getToastPlacement, useToast, useToastManager };
